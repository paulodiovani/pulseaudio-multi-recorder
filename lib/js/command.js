// Generated by CoffeeScript 1.7.1
(function() {
  var Command, PulseAudio, spawn;

  PulseAudio = require('pulseaudio');

  spawn = require('child_process').spawn;


  /*
   * Command class
   * Run pulseaudio commands
   */

  Command = (function() {

    /*
     * How to name the client on server
     */
    Command.prototype.client_name = 'pulseaudio-multi-recorder';


    /*
     * Default stream for errors (default: process.stderr)
     */

    Command.prototype.err_stream = process.stderr;


    /*
     * Array of child process spawned
     */

    Command.prototype.child_processes = [];

    function Command() {}


    /*
     * Set the error output stream.
     * @param {NodeStream} stream any writable stream who can receive text data
     */

    Command.prototype.set_error_stream = function(stream) {
      this.err_stream = stream;
      return this;
    };


    /*
     * List active sinks
     * @param {Function} node callback function to receive the list as argument
     * @return {Command} this
     */

    Command.prototype.list_sinks = function(callback) {
      var e, pa_context;
      if (callback == null) {
        callback = function() {};
      }
      try {
        pa_context = new PulseAudio({
          client: this.client_name
        });
        pa_context.on('connection', function() {
          return pa_context.sink(function(list) {
            callback(null, list);
            return pa_context.end();
          });
        });
      } catch (_error) {
        e = _error;
        callback(e.stack || e);
      }
      return this;
    };


    /*
     * List active sink inputs
     * @param {Function} node callback function to receive the list as argument
     * @return {Command} this
     */

    Command.prototype.list_sink_inputs = function(callback) {
      var buffer, e, pacmd;
      if (callback == null) {
        callback = function() {};
      }
      try {
        pacmd = spawn('pacmd', ['list-sink-inputs']);
        buffer = '';
        pacmd.stdout.on('data', function(data) {
          return buffer += data.toString();
        });
        pacmd.stdout.on('end', function() {
          return callback(null, buffer);
        });
      } catch (_error) {
        e = _error;
        callback(e.stack || e);
      }
      return this;
    };


    /*
     * List active sources
     * @param {Function} node callback function to receive the list as argument
     * @return {Command} this
     */

    Command.prototype.list_sources = function(callback) {
      var e, pa_context;
      if (callback == null) {
        callback = function() {};
      }
      try {
        pa_context = new PulseAudio({
          client: this.client_name
        });
        pa_context.on('connection', function() {
          return pa_context.source(function(list) {
            callback(null, list);
            return pa_context.end();
          });
        });
      } catch (_error) {
        e = _error;
        callback(e.stack || e);
      }
      return this;
    };


    /*
     * Record a source using parec and convert to ogg
     * @param {String} source_name source to record
     * @param {String} out_file filename to record to (optional)
     * @param {Function} node callback function to receive the list as argument
     * @return {Command} this
     */

    Command.prototype.start_record = function(source_name, out_file, callback) {
      var e, oggenc, parec;
      if (out_file == null) {
        out_file = "record-" + (new Date().getTime().toString(16)) + ".ogg";
      }
      if (callback == null) {
        callback = function() {};
      }
      try {
        parec = spawn('parec', ['-d', source_name, '-n', this.client_name]);
        oggenc = spawn('oggenc', ['-b', '192', '-o', out_file, '--raw', '-']);
        this.child_processes.push({
          process: parec
        });
        this.child_processes.push({
          process: oggenc
        });
        parec.stdout.pipe(oggenc.stdin);
        parec.stderr.pipe(this.err_stream);
        oggenc.stderr.pipe(this.err_stream);
        parec.on('end', callback);
      } catch (_error) {
        e = _error;
        callback(e.stack || e);
      }
      return this;
    };


    /*
     * Lista os processos filhos em execução
     * @param {Function} node callback function to receive the list as argument
     * @return {Command} this
     */

    Command.prototype.list_child_process = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      callback(null, this.child_processes);
      return this;
    };

    return Command;

  })();

  module.exports = new Command();

}).call(this);
